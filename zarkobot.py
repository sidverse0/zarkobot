# -*- coding: utf-8 -*-
import json
import requests
import asyncio
import hashlib
import random
import string
import os
import asyncpg
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters
)

# ==== CONFIG ====
# Apne bot ka token yahan daalein ya environment variable se lein
BOT_TOKEN = os.environ.get("BOT_TOKEN", "8116705267:AAGVx7azJJMndrXHwzoMnx7angKd0COJWjg")
# Render.com se mila DATABASE_URL environment variable se liya jayega
DATABASE_URL = os.environ.get("DATABASE_URL")

CHANNEL_USERNAME = "@chandhackz_78"   # Main channel
CHANNEL_USERNAME_2 = "@zarkoworld"  # Second channel
OWNER_USERNAME = "@pvt_s1n"    # Aapka username

LEAKOSINT_API_TOKEN = os.environ.get("LEAKOSINT_API_TOKEN", "8176139267:btRibc7y")
API_URL = "https://leakosintapi.com/"

AUDIT_LOG_FILE = "audit.log"

# ==== Security Functions ====
def generate_user_hash(user_id):
    """User identification ke liye 6-digit alphanumeric hash generate karein"""
    random.seed(user_id)
    characters = string.ascii_uppercase + string.digits
    return ''.join(random.choice(characters) for _ in range(6))

def log_audit_event(user_id, event_type, details):
    """Monitoring ke liye security events log karein"""
    timestamp = datetime.now().isoformat()
    user_hash = generate_user_hash(user_id)
    
    log_entry = {
        "timestamp": timestamp,
        "user_id": user_id,
        "user_hash": user_hash,
        "event_type": event_type,
        "details": details
    }
    
    try:
        with open(AUDIT_LOG_FILE, "a", encoding="utf-8") as f:
            f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")
    except Exception as e:
        print(f"Audit log error: {e}")

# ==== Database Functions ====
async def init_db(app: Application):
    """Database connection pool banayein aur table ensure karein"""
    try:
        pool = await asyncpg.create_pool(DATABASE_URL)
        app.bot_data["pool"] = pool
        async with pool.acquire() as connection:
            await connection.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    user_id BIGINT PRIMARY KEY,
                    credits INTEGER DEFAULT 0,
                    name TEXT,
                    last_update TIMESTAMPTZ,
                    initial_credits_given BOOLEAN DEFAULT FALSE,
                    join_date DATE,
                    user_hash TEXT,
                    verification_history JSONB,
                    last_verified TIMESTAMPTZ
                )
            ''')
        print("Database connection pool initialized and table ensured.")
    except Exception as e:
        print(f"FATAL: Database connection failed: {e}")
        # Agar DB connect na ho to bot ko band kar dein
        os._exit(1)


async def get_user(pool, user_id):
    """Database se user data fetch karein"""
    async with pool.acquire() as connection:
        user_record = await connection.fetchrow("SELECT * FROM users WHERE user_id = $1", user_id)
        return dict(user_record) if user_record else None

async def upsert_user(pool, user_id, name, credits=None, last_verified=None, initial_credits_given=None):
    """User ko create ya update karein (UPSERT operation)"""
    user_hash = generate_user_hash(user_id)
    async with pool.acquire() as connection:
        # Pehle se user hai ya nahi, check karein
        existing_user = await get_user(pool, user_id)
        
        if existing_user:
            # User hai, to update karein
            update_fields = {"name": name, "last_update": datetime.now()}
            if credits is not None:
                update_fields["credits"] = credits
            if last_verified is not None:
                update_fields["last_verified"] = last_verified
            
            set_clauses = [f"{key} = ${i+2}" for i, key in enumerate(update_fields.keys())]
            query = f"UPDATE users SET {', '.join(set_clauses)} WHERE user_id = $1"
            await connection.execute(query, user_id, *update_fields.values())
        else:
            # Naya user, to insert karein
            await connection.execute(
                """
                INSERT INTO users (user_id, name, credits, join_date, user_hash, last_update, last_verified, initial_credits_given, verification_history)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                """,
                user_id,
                name,
                credits if credits is not None else 2, # Default 2 credits
                datetime.now().date(),
                user_hash,
                datetime.now(),
                last_verified,
                initial_credits_given if initial_credits_given is not None else True,
                json.dumps([]) # Initial empty history
            )
        
        log_audit_event(user_id, "USER_UPSERT", f"Name: {name}, Credits: {credits}")
        return await get_user(pool, user_id)

async def add_verification_record(pool, user_id, success, details):
    """User ki verification history mein naya record add karein"""
    async with pool.acquire() as connection:
        user = await get_user(pool, user_id)
        if not user:
            return False
            
        history = json.loads(user.get("verification_history", "[]")) if isinstance(user.get("verification_history"), str) else user.get("verification_history", [])
        
        record = {
            "timestamp": datetime.now().isoformat(),
            "success": success,
            "details": details
        }
        history.append(record)
        
        # Sirf aakhri 10 records rakhein
        history = history[-10:]
        
        await connection.execute(
            "UPDATE users SET verification_history = $1 WHERE user_id = $2",
            json.dumps(history), user_id
        )
        return True

async def get_admin_stats(pool):
    """Admin ke liye stats fetch karein"""
    async with pool.acquire() as connection:
        stats = await connection.fetchrow("SELECT COUNT(*) as total_users, SUM(credits) as total_credits FROM users")
        return dict(stats) if stats else {"total_users": 0, "total_credits": 0}

# ==== Check Channel Membership ====
async def check_membership(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id):
    try:
        member1 = await context.bot.get_chat_member(chat_id=CHANNEL_USERNAME, user_id=user_id)
        member2 = await context.bot.get_chat_member(chat_id=CHANNEL_USERNAME_2, user_id=user_id)
        is_member = member1.status != "left" and member2.status != "left"
        log_audit_event(user_id, "MEMBERSHIP_CHECK", f"Channel1: {member1.status}, Channel2: {member2.status}, Result: {is_member}")
        return is_member
    except Exception as e:
        error_msg = f"Error checking membership: {e}"
        print(error_msg)
        log_audit_event(user_id, "MEMBERSHIP_ERROR", error_msg)
        return False

# ==== API Query ====
def query_leakosint(query: str):
    payload = {"token": LEAKOSINT_API_TOKEN, "request": query, "limit": 500, "lang": "en"}
    try:
        resp = requests.post(API_URL, json=payload, timeout=30)
        return resp.json()
    except Exception as e:
        return {"Error": str(e)}

# ==== Format Result ====
def format_results(resp):
    if "Error" in resp or "Error code" in resp:
        err = resp.get("Error") or resp.get("Error code")
        return f"‚ö†Ô∏è S·¥á Ä·¥†·¥á Ä IÍú± O…¥ M·¥Ä…™…¥·¥õ·¥Ä…™…¥·¥á…¥·¥Ñ·¥á"

    msg = ""
    for db, data in resp.get("List", {}).items():
        for row in data.get("Data", []):
            # ... (formatting logic same as before)
            name = row.get("FatherName", "N/A")
            father = row.get("FullName", "N/A")
            mobile = row.get("Phone", "N/A")
            alt1 = row.get("Phone2", "N/A")
            alt2 = row.get("Phone3", "N/A")
            alt3 = row.get("Phone4", "N/A")
            alt4 = row.get("Phone5", "N/A")
            alt5 = row.get("Phone6", "N/A")
            doc = row.get("DocNumber", "N/A")
            region = row.get("Region", "N/A")
            address = row.get("Address", "N/A")

            msg += f"""
üë§ N·¥Ä·¥ç·¥á ‚û§ {name}
üßì F·¥Ä·¥õ ú·¥á Ä'Íú± N·¥Ä·¥ç·¥á ‚û§ {father}
üì± M·¥è ô…™ ü·¥á ‚û§ {mobile}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä1 ‚û§ {alt1}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä2 ‚û§ {alt2}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä3 ‚û§ {alt3}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä4 ‚û§ {alt4}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä5 ‚û§ {alt5}
üÜî A·¥Ä·¥Ö ú·¥Ä Ä ùô∏ùô≥ ‚û§ {doc}
üì∂ C…™ Ä·¥Ñ ü·¥á ‚û§ {region}
üè† A·¥Ö·¥Ö Ä·¥áÍú±Íú± ‚û§ {address}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"""
    return msg or "‚ùå N·¥è D·¥Ä·¥õ·¥Ä A·¥†·¥Ä…™ ü·¥Ä ô ü·¥á I…¥ D·¥Ä·¥õ·¥Ä ô·¥ÄÍú±·¥á"

# ==== Show Profile Function ====
async def show_profile(update, context, user_id=None, user_data=None, edit_message=False):
    if not user_id:
        user_id = update.effective_user.id
        
    if not user_data:
        pool = context.bot_data["pool"]
        user_data = await get_user(pool, user_id)
    
    if not user_data:
        user_data = {"credits": 0, "last_update": "N/A", "name": "Unknown", "join_date": "N/A"}

    name = user_data.get("name", "Unknown")
    credits = user_data.get("credits", 0)
    last_update = user_data.get("last_update").strftime("%Y-%m-%d %I:%M:%S %p") if user_data.get("last_update") else "N/A"
    join_date = user_data.get("join_date").strftime("%Y-%m-%d") if user_data.get("join_date") else "N/A"
    user_hash = user_data.get("user_hash", generate_user_hash(user_id))
    
    profile_msg = f"""
üë§ N·¥Ä·¥ç·¥á ‚ñ∂ {name} 
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üÜî Us·¥á Ä …™·¥Ö ‚ñ∂ {user_id}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üÜî Us·¥á Ä H·¥Äs ú ‚ñ∂ {user_hash}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üíµ C Ä·¥á·¥Ö…™·¥õ ‚ñ∂ {credits} üíé
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üìÖ J·¥è…™…¥·¥á·¥Ö ·¥è…¥ ‚ñ∂ {join_date}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
‚åöÔ∏è L·¥Äs·¥õ U·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö ‚ñ∂ {last_update}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
"""
    keyboard = [
        [InlineKeyboardButton("‚ùì Help", callback_data="help"),
         InlineKeyboardButton("üîç Search", callback_data="search_prompt")],
        [InlineKeyboardButton("üí≥ Buy Credits", callback_data="buy")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if edit_message and hasattr(update, 'callback_query'):
        await update.callback_query.edit_message_text(profile_msg, reply_markup=reply_markup)
    elif hasattr(update, 'message'):
        await update.message.reply_text(profile_msg, reply_markup=reply_markup)
    else:
        await update.callback_query.message.reply_text(profile_msg, reply_markup=reply_markup)

# ==== Buy Command Function ====
async def buy_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    is_member = await check_membership(update, context, user_id)
    if not is_member:
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîê Ôº∂Ôº•Ôº≤Ôº©Ôº¶Ôºπ", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("‚ö†Ô∏è Y·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥ä·¥è…™…¥ ·¥Ä ü ü ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú± ·¥Ä…¥·¥Ö ·¥†·¥á Ä…™“ì è ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ.", reply_markup=reply_markup)
        return
        
    buy_message = """
‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ
... (buy message content same as before) ...
"""

    keyboard = [
        [InlineKeyboardButton("üí¨ C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ O·¥°…¥·¥á Ä", url=f"https://t.me/{OWNER_USERNAME[1:]}")],
        [InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(buy_message, reply_markup=reply_markup)

# ==== Fast Animated Spinner ====
async def show_spinner(update, context, message):
    spinner_frames = ["ìÜó ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢ D·¥è…¥·¥á "]
    msg = await message.reply_text(spinner_frames[0])
    await asyncio.sleep(0.5)
    return msg

# ==== Handlers ====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    name = update.effective_user.first_name
    pool = context.bot_data["pool"]
    
    log_audit_event(user_id, "START_COMMAND", f"User: {name}")
    
    user_data = await get_user(pool, user_id)
    is_member = await check_membership(update, context, user_id)
    
    if is_member:
        if not user_data:
            user_data = await upsert_user(pool, user_id, name, credits=2, last_verified=datetime.now(), initial_credits_given=True)
            await add_verification_record(pool, user_id, True, "New user - initial credits granted")
            
            await update.message.reply_text(
                "üçë V·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ S·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü! üéâüéä\n\n"
                "‚ú® Y·¥è·¥ú'·¥†·¥á R·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö  üíé 2 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú±\n\n"
                "üöÄ Use Bot Enter Number Like +91********** Format"
            )
        else:
            user_data = await upsert_user(pool, user_id, name=name)
            await add_verification_record(pool, user_id, True, "Existing user - membership verified")
        
        await show_profile(update, context, user_id, user_data)
    else:
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîê Ôº∂Ôº•Ôº≤Ôº©Ôº¶Ôºπ", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        if user_data:
            await add_verification_record(pool, user_id, False, "User not member of required channels")
        
        await update.message.reply_text(
            "‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ\n\n"
            "‚úÆ ü§ñ T·¥è UÍú±·¥á T ú…™Íú± B·¥è·¥õ Y·¥è·¥ú M·¥úÍú±·¥õ:\n\n"
            "‚úÆ üîó J·¥è…™…¥ B·¥è·¥õ ú OÍú∞Íú∞…™·¥Ñ…™·¥Ä ü C ú·¥Ä…¥…¥·¥á ü A ô·¥è·¥†·¥á\n"
            "‚úÆ üîê C ü…™·¥Ñ·¥ã T ú·¥á V·¥á Ä…™Íú∞ è B·¥ú·¥õ·¥õ·¥è…¥\n\n"
            "‚úÆüéÅ R·¥á·¥°·¥Ä Ä·¥Ö: AÍú∞·¥õ·¥á Ä V·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥  Y·¥è·¥ú W…™ ü ü  I…¥Íú±·¥õ·¥Ä…¥·¥õ ü è R·¥á·¥Ñ·¥á…™·¥†·¥á\n"
            "‚úÆüíé 2 F Ä·¥á·¥Ö…™·¥õÍú±\n\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            "üåÄ B·¥ú è U…¥ ü…™·¥ç…™·¥õ·¥á·¥Ö C Ä·¥á·¥Ö…™·¥õÍú± & A·¥ò…™‚ö°C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ üëâ @pvt_s1n",
            reply_markup=reply_markup
        )

async def verify_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    name = update.effective_user.first_name
    pool = context.bot_data["pool"]
    
    is_member = await check_membership(update, context, user_id)
    user_data = await get_user(pool, user_id)
    
    if is_member:
        if not user_data:
            user_data = await upsert_user(pool, user_id, name, credits=2, last_verified=datetime.now(), initial_credits_given=True)
            await add_verification_record(pool, user_id, True, "New user - initial credits granted via verify")
            
            await query.edit_message_text(
                "üçë V·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ S·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú±Íú∞·¥ú ü! üéâüéä\n\n"
                "‚ú® Y·¥è·¥ú'·¥†·¥á R·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö  üíé 2 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú±\n\n"
                "üöÄ E…¥·¥ä·¥è è Y·¥è·¥ú Ä J·¥è·¥ú Ä…¥·¥á è W…™·¥õ ú ‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ"
            )
            await show_profile(update, context, user_id, user_data)
        else:
            user_data = await upsert_user(pool, user_id, name=name, last_verified=datetime.now())
            await add_verification_record(pool, user_id, True, "Existing user - reverified")
            
            await query.edit_message_text(
                "‚úÖ Y·¥è·¥ú A Ä·¥á A ü Ä·¥á·¥Ä·¥Ö è ·¥Ä M·¥á·¥ç ô·¥á Ä A…¥·¥Ö H·¥Ä·¥†·¥á A ü Ä·¥á·¥Ä·¥Ö è R·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö Y·¥è·¥ú Ä I…¥…™·¥õ…™·¥Ä ü C Ä·¥á·¥Ö…™·¥õs.\n\n"
                "üöÄ E…¥·¥ä·¥è è Y·¥è·¥ú Ä J·¥è·¥ú Ä…¥·¥á è W…™·¥õ ú ‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ"
            )
            await show_profile(update, context, user_id, user_data)
    else:
        if user_data:
            await add_verification_record(pool, user_id, False, "Verification failed - not member of channels")
        
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîÑ Ôº£Ôº®Ôº•Ôº£Ôº´", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "‚îÅ‚îÅ‚îÅ‚ö†Ô∏è W·¥Ä Ä…¥…™…¥G ‚ö†Ô∏è‚îÅ‚îÅ‚îÅ\n\n"
            "üö´ Y·¥è·¥ú H·¥Ä·¥†·¥á…¥'·¥õ J·¥è…™…¥·¥á·¥Ö B·¥è·¥õ ú C ú·¥Ä…¥…¥·¥á üÍú± Y·¥á·¥õ!\n\n"
            "üì¢ P ü·¥á·¥ÄÍú±·¥á J·¥è…™…¥ B·¥è·¥õ ú C ú·¥Ä…¥…¥ ü·¥á A ô·¥è·¥†·¥á üì°\n"
            "üîÅ T ú·¥á…¥ C ü…™·¥Ñ·¥ã C ú·¥á·¥ãüîò\n\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            reply_markup=reply_markup
        )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    # ... (button handler logic same as before, just needs to call show_profile for 'profile' case)
    if query.data == "profile":
        user_id = update.effective_user.id
        await show_profile(update, context, user_id=user_id, edit_message=True)
    elif query.data == "help":
        # ... help text
        keyboard = [[InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]]
        await query.edit_message_text("Help text here...", reply_markup=InlineKeyboardMarkup(keyboard))
    elif query.data == "search_prompt":
        # ... search prompt text
        keyboard = [[InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]]
        await query.edit_message_text("Search prompt text here...", reply_markup=InlineKeyboardMarkup(keyboard))
    elif query.data == "buy":
        # ... buy message text
        keyboard = [
            [InlineKeyboardButton("üí¨ C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ O·¥°…¥·¥á Ä", url=f"https://t.me/{OWNER_USERNAME[1:]}")],
            [InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]
        ]
        await query.edit_message_text("Buy credits text here...", reply_markup=InlineKeyboardMarkup(keyboard))


async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    pool = context.bot_data["pool"]

    is_member = await check_membership(update, context, user_id)
    if not is_member:
        # ... (membership check logic same as before)
        return

    user_data = await get_user(pool, user_id)
    if not user_data:
        name = update.effective_user.first_name
        user_data = await upsert_user(pool, user_id, name, credits=2, last_verified=datetime.now(), initial_credits_given=True)
        await add_verification_record(pool, user_id, True, "New user - initial credits granted via search")

    if user_data["credits"] <= 0:
        keyboard = [[InlineKeyboardButton("üí≥ B·¥ú è C Ä·¥á·¥Ö…™·¥õÍú±", callback_data="buy")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(f"‚ùå N·¥è C Ä·¥á·¥Ö…™·¥õ L·¥áÍú∞·¥õ!\n\nüí≥B·¥ú è U…¥ ü…™·¥ç…™·¥õ·¥á·¥Ö üåÄ C Ä·¥á·¥Ö…™·¥õÍú± & A·¥ò…™‚ö°C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ üëâ {OWNER_USERNAME}", reply_markup=reply_markup)
        return

    spinner_msg = await show_spinner(update, context, update.message)
    query_text = update.message.text
    result = query_leakosint(query_text)
    msg = format_results(result)

    if "N·¥è D·¥Ä·¥õ·¥Ä" not in msg and "S·¥á Ä·¥†·¥á Ä" not in msg:
        new_credits = user_data["credits"] - 1
        user_data = await upsert_user(pool, user_id, user_data['name'], credits=new_credits)
        log_audit_event(user_id, "SEARCH", f"Query: {query_text}, Success: True, Credits left: {new_credits}")
    else:
        log_audit_event(user_id, "SEARCH", f"Query: {query_text}, Success: False, Credits left: {user_data['credits']}")

    await spinner_msg.delete()
    
    credits_left = user_data["credits"]
    msg += f"\nüíµ C Ä·¥á·¥Ö…™·¥õ : {credits_left} üíé"
    
    keyboard = [[InlineKeyboardButton("üí≥ B·¥ú è C Ä·¥á·¥Ö…™·¥õÍú±", callback_data="buy")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(msg, reply_markup=reply_markup)

async def credits(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    pool = context.bot_data["pool"]
    
    is_member = await check_membership(update, context, user_id)
    if not is_member:
        # ... (membership check logic same as before)
        return
        
    user_data = await get_user(pool, user_id)
    c = user_data.get("credits", 0) if user_data else 0
    await update.message.reply_text(f"üíµ Y·¥è·¥ú Ä C Ä·¥á·¥Ö…™·¥õÍú±: {c} üíé")

async def me(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    is_member = await check_membership(update, context, user_id)
    if not is_member:
        # ... (membership check logic same as before)
        return
        
    await show_profile(update, context, user_id)

async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    pool = context.bot_data["pool"]
    
    if user_id != 7975903577: # Aapki admin user ID
        await update.message.reply_text("‚ùå A·¥Ñ·¥Ñ·¥áÍú±Íú± D·¥á…¥…™·¥á·¥Ö.")
        return
        
    stats = await get_admin_stats(pool)
    stats_msg = f"""
‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñ Ôº°Ôº§Ôº≠Ôº©ÔºÆ  ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ

üë• T·¥è·¥õ·¥Ä ü Us·¥á Äs: {stats['total_users']}
üíé T·¥è·¥õ·¥Ä ü C Ä·¥á·¥Ö…™·¥õs: {stats['total_credits'] or 0}
üìä L·¥Äs·¥õ U·¥ò·¥Ö·¥Ä·¥õ·¥á: {datetime.now().strftime('%Y-%m-%d %I:%M:%S %p')}
"""
    await update.message.reply_text(stats_msg)

# ==== MAIN ====
def main():
    if not BOT_TOKEN:
        print("FATAL: BOT_TOKEN environment variable not set.")
        return
    if not DATABASE_URL:
        print("FATAL: DATABASE_URL environment variable not set.")
        return

    app = Application.builder().token(BOT_TOKEN).post_init(init_db).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("credits", credits))
    app.add_handler(CommandHandler("me", me))
    app.add_handler(CommandHandler("buy", buy_command))
    app.add_handler(CommandHandler("adminstats", admin_stats))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, search))
    app.add_handler(CallbackQueryHandler(verify_callback, pattern="^verify$"))
    app.add_handler(CallbackQueryHandler(button_handler, pattern="^(help|search_prompt|buy|profile)$"))

    print("‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ......")
    app.run_polling()

if __name__ == "__main__":
    main()