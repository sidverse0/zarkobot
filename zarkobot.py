# -*- coding: utf-8 -*-
import json
import requests
import asyncio
import hashlib
import random
import string
import os
from datetime import datetime, timedelta
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters
)
from pymongo import MongoClient
from bson import ObjectId

# ==== CONFIG ====
BOT_TOKEN = os.environ.get('BOT_TOKEN', "8116705267:AAGVx7azJJMndrXHwzoMnx7angKd0COJWjg")
CHANNEL_USERNAME = os.environ.get('CHANNEL_USERNAME', "@zarkoworld")   # Main channel
CHANNEL_USERNAME_2 = os.environ.get('CHANNEL_USERNAME_2', "@chandhackz_78")  # Second channel
OWNER_USERNAME = os.environ.get('OWNER_USERNAME', "@pvt_s1n")    # Your username
ADMIN_ID = int(os.environ.get('ADMIN_ID', 7975903577))  # Your user ID

LEAKOSINT_API_TOKEN = os.environ.get('LEAKOSINT_API_TOKEN', "8176139267:btRibc7y")
API_URL = os.environ.get('API_URL', "https://leakosintapi.com/")

# MongoDB Connection
MONGO_URI = os.environ.get('MONGO_URI', "mongodb+srv://Sidverse0:sidverse18@cluster0.50emoak.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0")

# Connect to MongoDB
try:
    client = MongoClient(MONGO_URI)
    db = client['zarkobot']
    users_collection = db['users']
    audit_collection = db['audit_logs']
    print("Connected to MongoDB successfully!")
except Exception as e:
    print(f"Error connecting to MongoDB: {e}")
    exit(1)

# ==== Security Functions ====
def generate_user_hash(user_id):
    """Generate a 6-digit alphanumeric hash for user identification"""
    # Create a consistent but unique 6-digit code for each user
    random.seed(user_id)  # Seed with user_id for consistency
    characters = string.ascii_uppercase + string.digits
    return ''.join(random.choice(characters) for _ in range(6))

def log_audit_event(user_id, event_type, details):
    """Log security events for monitoring"""
    timestamp = datetime.now().isoformat()
    user_hash = generate_user_hash(user_id)
    
    log_entry = {
        "timestamp": timestamp,
        "user_id": user_id,
        "user_hash": user_hash,
        "event_type": event_type,
        "details": details
    }
    
    try:
        audit_collection.insert_one(log_entry)
    except Exception as e:
        print(f"Audit log error: {e}")

# ==== User Data Functions ====
def load_users():
    """Get all users from MongoDB"""
    try:
        users = {}
        for user in users_collection.find():
            users[str(user["_id"])] = user
        return users
    except Exception as e:
        print(f"Error loading users: {e}")
        return {}

def save_users(users):
    """Save users to MongoDB"""
    try:
        for user_id, user_data in users.items():
            users_collection.update_one(
                {"_id": user_id},
                {"$set": user_data},
                upsert=True
            )
    except Exception as e:
        print(f"Error saving users: {e}")

def update_user(user_id, credits=None, name=None, last_verified=None):
    uid = str(user_id)
    
    # Get existing user or create new
    user_data = users_collection.find_one({"_id": uid})
    
    if not user_data:
        user_data = {
            "_id": uid,
            "credits": 0,
            "name": name or "Unknown", 
            "last_update": datetime.now().strftime("%Y-%m-%d %I:%M:%S %p"),
            "initial_credits_given": False,
            "join_date": datetime.now().strftime("%Y-%m-%d"),
            "user_hash": generate_user_hash(user_id),
            "verification_history": [],
            "last_verified": None
        }
        users_collection.insert_one(user_data)
    else:
        # Update fields if provided
        update_data = {}
        if credits is not None:
            update_data["credits"] = credits
        if name is not None:
            update_data["name"] = name
        if last_verified is not None:
            update_data["last_verified"] = last_verified
            
        update_data["last_update"] = datetime.now().strftime("%Y-%m-%d %I:%M:%S %p")
        
        if update_data:
            users_collection.update_one(
                {"_id": uid},
                {"$set": update_data}
            )
            user_data.update(update_data)
    
    # Log the update
    log_audit_event(user_id, "USER_UPDATE", f"Credits: {user_data.get('credits', 0)}, Name: {user_data.get('name', 'Unknown')}")
    
    return user_data

def add_verification_record(user_id, success, details):
    """Add a verification attempt to user's history"""
    uid = str(user_id)
    
    user_data = users_collection.find_one({"_id": uid})
    if not user_data:
        return False
    
    record = {
        "timestamp": datetime.now().isoformat(),
        "success": success,
        "details": details
    }
    
    # Update verification history
    users_collection.update_one(
        {"_id": uid},
        {
            "$push": {
                "verification_history": {
                    "$each": [record],
                    "$slice": -10  # Keep only last 10 records
                }
            }
        }
    )
    
    return True

# ==== Check Channel Membership ====
async def check_membership(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id):
    try:
        # Check first channel
        member1 = await context.bot.get_chat_member(chat_id=CHANNEL_USERNAME, user_id=user_id)
        # Check second channel
        member2 = await context.bot.get_chat_member(chat_id=CHANNEL_USERNAME_2, user_id=user_id)
        
        is_member = member1.status != "left" and member2.status != "left"
        
        # Log membership check
        log_audit_event(user_id, "MEMBERSHIP_CHECK", 
                       f"Channel1: {member1.status}, Channel2: {member2.status}, Result: {is_member}")
        
        return is_member
    except Exception as e:
        error_msg = f"Error checking membership: {e}"
        print(error_msg)
        log_audit_event(user_id, "MEMBERSHIP_ERROR", error_msg)
        return False

# ==== API Query ====
def query_leakosint(query: str):
    payload = {
        "token": LEAKOSINT_API_TOKEN,
        "request": query,
        "limit": 500,
        "lang": "en"
    }
    try:
        resp = requests.post(API_URL, json=payload, timeout=30)
        return resp.json()
    except Exception as e:
        return {"Error": str(e)}

# ==== Format Result ====
def format_results(resp):
    if "Error" in resp or "Error code" in resp:
        err = resp.get("Error") or resp.get("Error code")
        return f"‚ö†Ô∏è S·¥á Ä·¥†·¥á Ä IÍú± O…¥ M·¥Ä…™…¥·¥õ·¥Ä…™…¥·¥á…¥·¥Ñ·¥á"

    msg = ""
    for db, data in resp.get("List", {}).items():
        for row in data.get("Data", []):
            name = row.get("FatherName", "N/A")
            father = row.get("FullName", "N/A")
            mobile = row.get("Phone", "N/A")
            alt1 = row.get("Phone2", "N/A")
            alt2 = row.get("Phone3", "N/A")
            alt3 = row.get("Phone4", "N/A")
            alt4 = row.get("Phone5", "N/A")
            alt5 = row.get("Phone6", "N/A")
            doc = row.get("DocNumber", "N/A")
            region = row.get("Region", "N/A")
            address = row.get("Address", "N/A")

            msg += f"""
üë§ N·¥Ä·¥ç·¥á ‚û§ {name}
üßì F·¥Ä·¥õ ú·¥á Ä'Íú± N·¥Ä·¥ç·¥á ‚û§ {father}
üì± M·¥è ô…™ ü·¥á ‚û§ {mobile}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä1 ‚û§ {alt1}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä2 ‚û§ {alt2}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä3 ‚û§ {alt3}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä4 ‚û§ {alt4}
üìû A ü·¥õ N·¥ú·¥ç ô·¥á Ä5 ‚û§ {alt5}
üÜî A·¥Ä·¥Ö ú·¥Ä Ä ùô∏ùô≥ ‚û§ {doc}
üì∂ C…™ Ä·¥Ñ ü·¥á ‚û§ {region}
üè† A·¥Ö·¥Ö Ä·¥áÍú±Íú± ‚û§ {address}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"""
    return msg or "‚ùå N·¥è D·¥Ä·¥õ·¥Ä A·¥†·¥Ä…™ ü·¥Ä ô ü·¥á I…¥ D·¥Ä·¥õ·¥Ä ô·¥ÄÍú±·¥á"

# ==== Show Profile Function ====
async def show_profile(update, context, user_id=None, user_data=None, edit_message=False):
    if not user_id:
        user_id = update.effective_user.id
        
    if not user_data:
        user_data = users_collection.find_one({"_id": str(user_id)})
        if not user_data:
            user_data = {"credits": 0, "last_update": "N/A", "name": "Unknown"}
    
    name = user_data.get("name", "Unknown")
    credits = user_data.get("credits", 0)
    last_update = user_data.get("last_update", "N/A")
    join_date = user_data.get("join_date", "N/A")
    user_hash = user_data.get("user_hash", generate_user_hash(user_id))
    
    # Create profile message
    profile_msg = f"""
üë§ N·¥Ä·¥ç·¥á ‚ñ∂ {name} 
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üÜî Us·¥á Ä …™·¥Ö ‚ñ∂ {user_id}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üÜî Us·¥á Ä  ú·¥Äs ú ‚ñ∂ {user_hash}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üíµ C Ä·¥á·¥Ö…™·¥õ ‚ñ∂ {credits} üíé
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
üìÖ J·¥è…™…¥·¥á·¥Ö ·¥è…¥ ‚ñ∂ {join_date}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
‚åöÔ∏è L·¥Äs·¥õ U·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö ‚ñ∂ {last_update}
‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
"""
    # Create buttons
    keyboard = [
        [InlineKeyboardButton("‚ùì Help", callback_data="help"),
         InlineKeyboardButton("üîç Search", callback_data="search_prompt")],
        [InlineKeyboardButton("üí≥ Buy Credits", callback_data="buy")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if edit_message and hasattr(update, 'callback_query'):
        await update.callback_query.edit_message_text(profile_msg, reply_markup=reply_markup)
    elif hasattr(update, 'message'):
        await update.message.reply_text(profile_msg, reply_markup=reply_markup)
    else:
        await update.callback_query.message.reply_text(profile_msg, reply_markup=reply_markup)

# ==== Buy Command Function ====
async def buy_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Check membership first
    is_member = await check_membership(update, context, user_id)
    if not is_member:
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîê Ôº∂Ôº•Ôº≤Ôº©Ôº¶Ôºπ", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("‚ö†Ô∏è Y·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥ä·¥è…™…¥ ·¥Ä ü ü ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú± ·¥Ä…¥·¥Ö ·¥†·¥á Ä…™“ì è ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ.", reply_markup=reply_markup)
        return
        
    buy_message = """
‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ

üíé C Ä·¥á·¥Ö…™·¥õ P ü·¥Ä…¥Íú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

1Ô∏è‚É£ S·¥õ·¥Ä Ä·¥õ·¥á Ä P·¥Ä·¥Ñ·¥ã üéØ 
‚ú®10 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ25 
üéÅB·¥è…¥·¥úÍú±: +2 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú± 
üí°B·¥áÍú±·¥õ Íú∞·¥è Ä ·¥õ·¥áÍú±·¥õ…™…¥…¢ ·¥õ ú·¥á ·¥Ä·¥ò·¥ò
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

2Ô∏è‚É£ V·¥Ä ü·¥ú·¥á P·¥Ä·¥Ñ·¥ã üì¶ 
‚ú®25 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ50 
üéÅB·¥è…¥·¥úÍú±: +5 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú± 
üí°P·¥è·¥ò·¥ú ü·¥Ä Ä ·¥Ñ ú·¥è…™·¥Ñ·¥á Íú∞·¥è Ä …¥·¥á·¥° ·¥úÍú±·¥á ÄÍú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

3Ô∏è‚É£ S·¥ç·¥Ä Ä·¥õ S·¥Ä·¥†·¥á Ä P·¥Ä·¥Ñ·¥ã ü™ô 
‚ú®50 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ90 
üéÅB·¥è…¥·¥úÍú±: +15 F Ä·¥á·¥Ö…™·¥õÍú± 
üí°M·¥è Ä·¥á ·¥ò ú·¥Ä·¥õ…™·¥ç·¥á, ·¥ç·¥è Ä·¥á  Ä·¥á·¥°·¥Ä Ä·¥ÖÍú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

4Ô∏è‚É£ P Ä·¥è P·¥Ä·¥Ñ·¥ã üöÄ 
‚ú®75 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ120 
üéÅB·¥è…¥·¥úÍú±: +25 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú± 
üí°B·¥áÍú±·¥õ Íú∞·¥è Ä  Ä·¥á…¢·¥ú ü·¥Ä Ä ·¥úÍú±·¥á ÄÍú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

5Ô∏è‚É£ M·¥á…¢·¥Ä P·¥Ä·¥Ñ·¥ã üëë 
‚ú®100 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ150 
üéÅB·¥è…¥·¥úÍú±: +40 F Ä·¥á·¥Ö…™·¥õÍú± 
üí°M·¥Äx…™·¥ç·¥ú·¥ç ·¥†·¥Ä ü·¥ú·¥á & Íú±·¥Ä·¥†…™…¥…¢Íú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîå A·¥ò…™ P·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üïí B·¥ú è A·¥ò…™ ‚Äî 1 M·¥è…¥·¥õ ú ‚Äî ‚Çπ399/-
üîíB·¥ú è A·¥ò…™ ‚Äî L…™Íú∞·¥á·¥õ…™·¥ç·¥á ‚Äî ‚Çπ1999/-
‚ÑπÔ∏èC·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ O·¥°…¥·¥á Ä Íú∞·¥è Ä ·¥ç·¥è Ä·¥á …™…¥Íú∞·¥è Ä·¥ç·¥Ä·¥õ…™·¥è…¥: @pvt_s1n
"""

    keyboard = [
        [InlineKeyboardButton("üí¨ C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ O·¥°…¥·¥á Ä", url=f"https://t.me/{OWNER_USERNAME[1:]}")],
        [InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(buy_message, reply_markup=reply_markup)

# ==== Fast Animated Spinner ====
async def show_spinner(update, context, message):
    spinner_frames = [
        "ìÜó ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢ D·¥è…¥·¥á "
    ]
    
    msg = await message.reply_text(spinner_frames[0])
    
    for frame in spinner_frames:
        await asyncio.sleep(0.5)
        try:
            await msg.edit_text(frame)
        except:
            break
    
    return msg

# ==== ADMIN FUNCTIONS ====
async def is_admin(user_id: int) -> bool:
    """Check if user is admin"""
    return user_id == ADMIN_ID

async def addcredits_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Add credits to a user"""
    user_id = update.effective_user.id
    if not await is_admin(user_id):
        await update.message.reply_text("‚ùå A·¥Ñ·¥Ñ·¥áÍú±Íú± D·¥á…¥…™·¥á·¥Ö.")
        return

    if len(context.args) != 2:
        await update.message.reply_text("‚ùå UÍú±·¥Ä…¢·¥á: /addcredits <user_id> <amount>")
        return

    try:
        target_user_id = int(context.args[0])
        amount = int(context.args[1])
    except ValueError:
        await update.message.reply_text("‚ùå I…¥·¥†·¥Ä ü…™·¥Ö ·¥úÍú±·¥á Ä ID ·¥è Ä ·¥Ä·¥ç·¥è·¥ú…¥·¥õ")
        return

    user_data = users_collection.find_one({"_id": str(target_user_id)})
    
    if not user_data:
        await update.message.reply_text("‚ùå UÍú±·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö")
        return

    new_credits = user_data.get("credits", 0) + amount
    users_collection.update_one(
        {"_id": str(target_user_id)},
        {"$set": {"credits": new_credits}}
    )
    
    log_audit_event(user_id, "ADMIN_ADD_CREDITS", 
                   f"Target: {target_user_id}, Amount: {amount}, New Balance: {new_credits}")
    
    await update.message.reply_text(f"‚úÖ A·¥Ö·¥Ö·¥á·¥Ö {amount} ·¥Ñ Ä·¥á·¥Ö…™·¥õÍú± ·¥õ·¥è ·¥úÍú±·¥á Ä {target_user_id}\nN·¥á·¥°  ô·¥Ä ü·¥Ä…¥·¥Ñ·¥á: {new_credits} üíé")

async def setcredits_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Set user's credits to specific amount"""
    user_id = update.effective_user.id
    if not await is_admin(user_id):
        await update.message.reply_text("‚ùå A·¥Ñ·¥Ñ·¥áÍú±Íú± D·¥á…¥…™·¥á·¥Ö.")
        return

    if len(context.args) != 2:
        await update.message.reply_text("‚ùå UÍú±·¥Ä…¢·¥á: /setcredits <user_id> <amount>")
        return

    try:
        target_user_id = int(context.args[0])
        amount = int(context.args[1])
    except ValueError:
        await update.message.reply_text("‚ùå I…¥·¥†·¥Ä ü…™·¥Ö ·¥úÍú±·¥á Ä ID ·¥è Ä ·¥Ä·¥ç·¥è·¥ú…¥·¥õ")
        return

    user_data = users_collection.find_one({"_id": str(target_user_id)})
    
    if not user_data:
        await update.message.reply_text("‚ùå UÍú±·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö")
        return

    users_collection.update_one(
        {"_id": str(target_user_id)},
        {"$set": {"credits": amount}}
    )
    
    log_audit_event(user_id, "ADMIN_SET_CREDITS", 
                   f"Target: {target_user_id}, New Amount: {amount}")
    
    await update.message.reply_text(f"‚úÖ S·¥á·¥õ ·¥Ñ Ä·¥á·¥Ö…™·¥õÍú± ·¥èÍú∞ ·¥úÍú±·¥á Ä {target_user_id} ·¥õ·¥è {amount} üíé")

async def userinfo_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Get user information"""
    user_id = update.effective_user.id
    if not await is_admin(user_id):
        await update.message.reply_text("‚ùå A·¥Ñ·¥Ñ·¥áÍú±Íú± D·¥á…¥…™·¥á·¥Ö.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("‚ùå UÍú±·¥Ä…¢·¥á: /userinfo <user_id>")
        return

    try:
        target_user_id = int(context.args[0])
    except ValueError:
        await update.message.reply_text("‚ùå I…¥·¥†·¥Ä ü…™·¥Ö ·¥úÍú±·¥á Ä ID")
        return

    user_data = users_collection.find_one({"_id": str(target_user_id)})
    
    if not user_data:
        await update.message.reply_text("‚ùå UÍú±·¥á Ä …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö")
        return

    info_msg = f"""
‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñ ÔºµÔº≥Ôº•Ôº≤ Ôº©ÔºÆÔº¶ÔºØ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ

üë§ N·¥Ä·¥ç·¥á: {user_data.get('name', 'N/A')}
üÜî Us·¥á Ä ID: {target_user_id}
üÜî Us·¥á Ä H·¥Äs ú: {user_data.get('user_hash', 'N/A')}
üíé C Ä·¥á·¥Ö…™·¥á·¥õÍú±: {user_data.get('credits', 0)}
üìÖ J·¥è…™…¥ D·¥Ä·¥õ·¥á: {user_data.get('join_date', 'N/A')}
‚åöÔ∏è L·¥Äs·¥õ U·¥ò·¥Ö·¥Ä·¥õ·¥á: {user_data.get('last_update', 'N/A')}
‚úÖ L·¥Äs·¥õ V·¥á Ä…™Íú∞…™·¥á·¥Ö: {user_data.get('last_verified', 'N/A')}

üìä V·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ H…™Íú±·¥õ·¥è Ä è:
"""
    
    for i, record in enumerate(user_data.get('verification_history', [])[-5:]):
        status = "‚úÖ" if record.get('success') else "‚ùå"
        info_msg += f"{i+1}. {status} {record.get('timestamp')} - {record.get('details')}\n"

    log_audit_event(user_id, "ADMIN_USERINFO", 
                   f"Viewed info for user: {target_user_id}")
    
    await update.message.reply_text(info_msg)

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Broadcast message to all users"""
    user_id = update.effective_user.id
    if not await is_admin(user_id):
        await update.message.reply_text("‚ùå A·¥Ñ·¥Ñ·¥áÍú±Íú± D·¥á…¥…™·¥á·¥Ö.")
        return

    if not context.args:
        await update.message.reply_text("‚ùå UÍú±·¥Ä…¢·¥á: /broadcast <message>")
        return

    message = " ".join(context.args)
    users = list(users_collection.find({}))
    success_count = 0
    fail_count = 0

    broadcast_msg = f"""
‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñ Ôº¢Ôº≤ÔºØÔº°Ôº§Ôº£Ôº°Ôº≥Ôº¥ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ

{message}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ú® Ôº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ
"""
    
    for user in users:
        try:
            await context.bot.send_message(chat_id=int(user["_id"]), text=broadcast_msg)
            success_count += 1
        except Exception as e:
            print(f"Failed to send to {user['_id']}: {e}")
            fail_count += 1
        await asyncio.sleep(0.1)  # Prevent flooding

    log_audit_event(user_id, "ADMIN_BROADCAST", 
                   f"Message: {message}, Success: {success_count}, Failed: {fail_count}")
    
    await update.message.reply_text(f"‚úÖ B Ä·¥è·¥Ä·¥Ö·¥Ñ·¥ÄÍú±·¥õ ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á·¥Ö!\nS·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±: {success_count}\nF·¥Ä…™ ü·¥á·¥Ö: {fail_count}")

# ==== Handlers ====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    name = update.effective_user.first_name
    
    # Log the start command
    log_audit_event(user_id, "START_COMMAND", f"User: {name}")
    
    # Check if user is already in database
    user_data = users_collection.find_one({"_id": str(user_id)})
    
    # Always check current membership status
    is_member = await check_membership(update, context, user_id)
    
    if is_member:
        # User is a member of channels
        if not user_data:
            # New user - add to database with initial credits
            user_data = update_user(user_id, credits=2, name=name, 
                                  last_verified=datetime.now().isoformat())
            add_verification_record(user_id, True, "New user - initial credits granted")
            
            await update.message.reply_text(
                "üçë V·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ S·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü! üéâüéä\n\n"
                "‚ú® Y·¥è·¥ú'·¥†·¥á R·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö  üíé 2 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú±\n\n"
                "üöÄ E…¥·¥ä·¥è è Y·¥è·¥ú Ä J·¥è·¥ú Ä…¥·¥á è W…™·¥õ ú ‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ"
            )
        else:
            # Existing user - just update name if needed
            user_data = update_user(user_id, name=name)
            add_verification_record(user_id, True, "Existing user - membership verified")
        
        await show_profile(update, context, user_id, user_data)
    else:
        # User hasn't joined both channels, show join buttons
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîê Ôº∂Ôº•Ôº≤Ôº©Ôº¶Ôºπ", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        add_verification_record(user_id, False, "User not member of required channels")
        
        await update.message.reply_text(
            "‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ\n\n"
            "‚úÆ ü§ñ T·¥è UÍú±·¥á T ú…™Íú± B·¥è·¥õ Y·¥è·¥ú M·¥úÍú±·¥õ:\n\n"
            "‚úÆ üîó J·¥è…™…¥ B·¥è·¥õ ú OÍú∞Íú∞…™·¥Ñ…™·¥Ä ü C ú·¥Ä…¥…¥·¥á ü A ô·¥è·¥†·¥á\n"
            "‚úÆ üîê C ü…™·¥Ñ·¥ã T ú·¥á V·¥á Ä…™Íú∞ è B·¥ú·¥õ·¥õ·¥è…¥\n\n"
            "‚úÆüéÅ R·¥á·¥°·¥Ä Ä·¥Ö: AÍú∞·¥õ·¥á Ä V·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥  Y·¥è·¥ú W…™ ü ü  I…¥Íú±·¥õ·¥Ä…¥·¥õ ü è R·¥á·¥Ñ·¥á…™·¥†·¥á\n"
            "‚úÆüíé 2 F Ä·¥á·¥Ö…™·¥õÍú±\n\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            "üåÄ B·¥ú è U…¥ ü…™·¥ç…™·¥õ·¥á·¥Ö C Ä·¥á·¥Ö…™·¥õÍú± & A·¥ò…™‚ö°C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ üëâ @pvt_s1n",
            reply_markup=reply_markup
        )

async def verify_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    name = update.effective_user.first_name
    
    # Check if user has joined both channels
    is_member = await check_membership(update, context, user_id)
    
    user_data = users_collection.find_one({"_id": str(user_id)})
    
    if is_member:
        if not user_data:
            # New user - add to database with initial credits
            user_data = update_user(user_id, credits=2, name=name, 
                                  last_verified=datetime.now().isoformat())
            add_verification_record(user_id, True, "New user - initial credits granted via verify")
            
            # Show success message and immediately show profile
            await query.edit_message_text(
                "üçë V·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ S·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú±Íú∞·¥ú ü! üéâüéä\n\n"
                "‚ú® Y·¥è·¥ú'·¥†·¥á R·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö  üíé 2 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú±\n\n"
                "üöÄ E…¥·¥ä·¥è è Y·¥è·¥ú Ä J·¥è·¥ú Ä…¥·¥á è W…™·¥õ ú ‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ"
            )
            await show_profile(update, context, user_id, user_data)
        else:
            # Existing user - update verification status but don't give credits again
            user_data = update_user(user_id, name=name, 
                                  last_verified=datetime.now().isoformat())
            add_verification_record(user_id, True, "Existing user - reverified")
            
            await query.edit_message_text(
                "‚úÖ Y·¥è·¥ú A Ä·¥á A ü Ä·¥á·¥Ä·¥Ö è ·¥Ä M·¥á·¥ç ô·¥á Ä A…¥·¥Ö H·¥Ä·¥†·¥á A ü Ä·¥á·¥Ä·¥Ö è R·¥á·¥Ñ·¥á…™·¥†·¥á·¥Ö Y·¥è·¥ú Ä I…¥…™·¥õ…™·¥Ä ü C Ä·¥á·¥Ö…™·¥õs.\n\n"
                "üöÄ E…¥·¥ä·¥è è Y·¥è·¥ú Ä J·¥è·¥ú Ä…¥·¥á è W…™·¥õ ú ‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ"
            )
            await show_profile(update, context, user_id, user_data)
    else:
        # User hasn't joined both channels
        add_verification_record(user_id, False, "Verification failed - not member of channels")
        
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîÑ Ôº£Ôº®Ôº•Ôº£Ôº´", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "‚îÅ‚îÅ‚îÅ‚ö†Ô∏è W·¥Ä Ä…¥…™…¥G ‚ö†Ô∏è‚îÅ‚îÅ‚îÅ\n\n"
            "üö´ Y·¥è·¥ú H·¥Ä·¥†·¥á…¥'·¥õ J·¥è…™…¥·¥á·¥Ö B·¥è·¥õ ú C ú·¥Ä…¥…¥·¥á üÍú± Y·¥á·¥õ!\n\n"
            "üì¢ P ü·¥á·¥ÄÍú±·¥á J·¥è…™…¥ B·¥è·¥õ ú C ú·¥Ä…¥…¥ ü·¥á A ô·¥è·¥†·¥á üì°\n"
            "üîÅ T ú·¥á…¥ C ü…™·¥Ñ·¥ã C ú·¥á·¥ãüîò\n\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            reply_markup=reply_markup
        )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == "help":
        help_text = """‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ

üîç *H·¥è·¥° T·¥è UÍú±·¥á Ôº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ:*

‚úØ üì± *P ú·¥è…¥·¥á N·¥ú·¥ç ô·¥á S·¥á·¥Ä Ä·¥Ñ ú* ‚Äì S·¥á…¥·¥Ö N·¥è. L…™·¥ã·¥á  `91XXXXXXXXXX`
‚úØ üìß *E·¥ç·¥Ä…™ ü S·¥á·¥Ä Ä·¥Ñ ú* ‚Äì S·¥á…¥·¥Ö E·¥ç·¥Ä…™ ô L…™·¥ã·¥á  `example@gmail.com`
‚úØ üë§ *N·¥Ä·¥ç·¥á S·¥á·¥Ä Ä·¥Ñ ú* ‚Äì J·¥úÍú±·¥õ S·¥á…¥·¥Ö T ú·¥á N·¥Ä·¥ç·¥á
‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£
üìÇ I W…™ ü ü S·¥Ñ·¥Ä…¥ A·¥Ñ Ä·¥èÍú±Íú± M·¥ú ü·¥õ…™·¥ò ü·¥á D·¥Ä·¥õ·¥Ä ô·¥ÄÍú±·¥áÍú± üóÇÔ∏è
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚òõ *N·¥è·¥õ·¥á:* E·¥Ä·¥Ñ ú S·¥á·¥Ä Ä·¥Ñ ú C·¥èÍú±·¥õÍú± üíé 1 C Ä·¥á·¥Ö…™·¥õ
"""
        keyboard = [[InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(help_text, parse_mode="Markdown", reply_markup=reply_markup)
        
    elif query.data == "search_prompt":
        search_prompt_text = """‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ

üîç *W ú·¥Ä·¥õ C·¥Ä…¥ …™ D·¥è?*

‚òõ üì± *P ú·¥è…¥·¥á N·¥ú·¥ç ô·¥á S·¥á·¥Ä Ä·¥Ñ ú* ‚Äì S·¥á…¥·¥á N·¥è. L…™·¥ã·¥á  `91XXXXXXXXXX`
‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£
‚òõ üìß *E·¥ç·¥Ä…™ ü S·¥á·¥Ä Ä·¥Ñ ú* ‚Äì S·¥á…¥·¥Ö E·¥ç·¥Ä…™ ü L…™·¥ã·¥á  `example@gmail.com`
‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£
‚òõ üë§ *N·¥Ä·¥ç·¥á S·¥á·¥Ä Ä·¥Ñ ú* ‚Äì J·¥úÍú±·¥õ S·¥á…¥·¥Ö T ú·¥á N·¥Ä·¥ç·¥á
‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£‚Ü£
üìÇ I W…™ ü ü S·¥Ñ·¥Ä…¥ A·¥Ñ Ä·¥èÍú±Íú± M·¥ú ü·¥õ…™·¥ò ü·¥á D·¥Ä·¥õ·¥Ä ô·¥ÄÍú±·¥áÍú± üóÇÔ∏è
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö†Ô∏è *N·¥è·¥õ·¥á:* E·¥Ä·¥Ñ ú S·¥á·¥Ä Ä·¥Ñ ú C·¥èÍú±·¥õÍú± üíé 1 C Ä·¥á·¥Ö…™·¥õ
"""
        keyboard = [[InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(search_prompt_text, parse_mode="Markdown", reply_markup=reply_markup)
        
    elif query.data == "buy":
        buy_message = """
‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ·öÄ·öÄ

üíé C Ä·¥á·¥Ö…™·¥õ P ü·¥Ä…¥Íú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

1Ô∏è‚É£ S·¥õ·¥Ä Ä·¥õ·¥á Ä P·¥Ä·¥Ñ·¥ã üéØ 
‚ú®10 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ25 
üéÅB·¥è…¥·¥úÍú±: +2 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú± 
üí°B·¥áÍú±·¥õ Íú∞·¥è Ä ·¥õ·¥áÍú±·¥õ…™…¥…¢ ·¥õ ú·¥á ·¥Ä·¥ò·¥ê
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

2Ô∏è‚É£ V·¥Ä ü·¥ú·¥á P·¥Ä·¥Ñ·¥ã üì¶ 
‚ú®25 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ50 
üéÅB·¥è…¥·¥úÍú±: +5 F Ä·¥á·¥Ö…™·¥õÍú± 
üí°P·¥è·¥ò·¥ú ü·¥Ä ú ·¥Ñ ú·¥è…™·¥Ñ·¥á Íú∞·¥è Ä …¥·¥á·¥° ·¥úÍú±·¥á ÄÍú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

3Ô∏è‚É£ S·¥ç·¥Ä Ä·¥õ S·¥Ä·¥†·¥á Ä P·¥Ä·¥Ñ·¥ã ü™ô 
‚ú®50 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ90 
üéÅB·¥è…¥·¥úÍú±: +15 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú± 
üí°M·¥è ú·¥á ·¥ò ú·¥Ä·¥õ…™·¥ç·¥á, ·¥ç·¥è Ä·¥á  Ä·¥á·¥°·¥Ä Ä·¥ÖÍú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

4Ô∏è‚É£ P Ä·¥è P·¥Ä·¥Ñ·¥ã üöÄ 
‚ú®75 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ120 
üéÅB·¥è…¥·¥úÍú±: +25 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú± 
üí°B·¥áÍú±·¥õ Íú∞·¥è Ä  Ä·¥á…¢·¥ú ü·¥Ä Ä ·¥úÍú±·¥á ÄÍú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

5Ô∏è‚É£ M·¥á…¢·¥Ä P·¥Ä·¥Ñ·¥ã üëë 
‚ú®100 C Ä·¥á·¥Ö…™·¥õÍú± ‚Üí ‚Çπ150 
üéÅB·¥è…¥·¥úÍú±: +40 F Ä·¥á·¥á C Ä·¥á·¥Ö…™·¥õÍú± 
üí°M·¥Äx…™·¥ç·¥ú·¥ç ·¥†·¥Ä ü·¥ú·¥á & Íú±·¥Ä·¥†…™…¥…¢Íú±
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîå A·¥ò…™ P·¥ú Ä·¥Ñ ú·¥ÄÍú±·¥á
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üïí B·¥ú è A·¥ò…™ ‚Äî 1 M·¥è…¥·¥õ ú ‚Äî ‚Çπ399/-
üîíB·¥ú è A·¥ò…™ ‚Äî L…™Íú∞·¥á·¥õ…™·¥ç·¥á ‚Äî ‚Çπ1999/-
‚ÑπÔ∏èC·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ O·¥°…¥·¥á Ä Íú∞·¥è Ä ·¥ç·¥è Ä·¥á …™…¥Íú∞·¥è Ä·¥ç·¥Ä·¥õ…™·¥ú…¥: @pvt_s1n
"""

        keyboard = [
            [InlineKeyboardButton("üí¨ C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ O·¥°…¥·¥á Ä", url=f"https://t.me/{OWNER_USERNAME[1:]}")],
            [InlineKeyboardButton("üîô B·¥Ä·¥Ñ·¥ã", callback_data="profile")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(buy_message, reply_markup=reply_markup)
        
    elif query.data == "profile":
        user_id = update.effective_user.id
        user_data = users_collection.find_one({"_id": str(user_id)})
        if not user_data:
            user_data = {"credits": 0, "last_update": "N/A", "name": "Unknown"}
        await show_profile(update, context, user_id, user_data, edit_message=True)

async def search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id

    # Check membership first
    is_member = await check_membership(update, context, user_id)
    if not is_member:
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîê Ôº∂Ôº•Ôº≤Ôº©Ôº¶Ôºπ", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("‚ö†Ô∏è Y·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥ä·¥è…™…¥ ·¥Ä ü ü ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú± ·¥Ä…¥·¥Ö ·¥†·¥á Ä…™“ì è ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ.", reply_markup=reply_markup)
        return

    user_data = users_collection.find_one({"_id": str(user_id)})
    
    if not user_data:
        # New user - add to database with initial credits
        name = update.effective_user.first_name
        user_data = update_user(user_id, credits=2, name=name, last_verified=datetime.now().isoformat())
        add_verification_record(user_id, True, "New user - initial credits granted via search")

    if user_data.get("credits", 0) <= 0:
        keyboard = [[InlineKeyboardButton("üí≥ B·¥ú è C Ä·¥á·¥Ö…™·¥õÍú±", callback_data="buy")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(f"‚ùå N·¥è C Ä·¥á·¥Ö…™·¥õ L·¥áÍú∞·¥õ!\n\nüí≥B·¥ú è U…¥ ü…™·¥ç…™·¥õ·¥á·¥Ö üåÄ C Ä·¥á·¥Ö…™·¥õÍú± & A·¥ò…™‚ö°C·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ üëâ {OWNER_USERNAME}", reply_markup=reply_markup)
        return

    # Show animated spinner
    spinner_msg = await show_spinner(update, context, update.message)

    query = update.message.text
    result = query_leakosint(query)
    msg = format_results(result)

    # Deduct 1 credit only if search was successful
    if "N·¥è D·¥Ä·¥õ·¥Ä" not in msg and "S·¥á Ä·¥†·¥á Ä" not in msg:
        new_credits = user_data.get("credits", 0) - 1
        users_collection.update_one(
            {"_id": str(user_id)},
            {"$set": {"credits": new_credits, "last_update": datetime.now().strftime("%Y-%m-%d %I:%M:%S %p")}}
        )
        
        # Log the search
        log_audit_event(user_id, "SEARCH", f"Query: {query}, Success: True, Credits left: {new_credits}")
    else:
        # Log failed search
        log_audit_event(user_id, "SEARCH", f"Query: {query}, Success: False, Credits left: {user_data.get('credits', 0)}")

    # Delete spinner message
    await spinner_msg.delete()

    # Add credits info and deposit button
    user_data = users_collection.find_one({"_id": str(user_id)})
    credits_left = user_data.get("credits", 0) if user_data else 0
    msg += f"\nüíµ C Ä·¥á·¥Ö…™·¥õ : {credits_left} üíé"
    
    keyboard = [[InlineKeyboardButton("üí≥ B·¥ú è C Ä·¥á·¥Ö…™·¥õÍú±", callback_data="buy")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(msg, reply_markup=reply_markup)

async def credits(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Check membership first
    is_member = await check_membership(update, context, user_id)
    if not is_member:
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØÔº©ÔºÆ", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîê Ôº∂Ôº•Ôº≤Ôº©Ôº¶Ôºπ", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("‚ö†Ô∏è Y·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥ä·¥è…™…¥ ·¥Ä ü ü ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú± ·¥Ä…¥·¥Ö ·¥†·¥á Ä…™“ì è ·¥õ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ.", reply_markup=reply_markup)
        return
        
    user_data = users_collection.find_one({"_id": str(user_id)})
    c = user_data.get("credits", 0) if user_data else 0
    await update.message.reply_text(f"üíµ Y·¥è·¥ú Ä C Ä·¥á·¥Ö…™·¥õÍú±: {c} üíé")

async def me(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Check membership first
    is_member = await check_membership(update, context, user_id)
    if not is_member:
        keyboard = [
            [InlineKeyboardButton("üì¢ Ôº™ÔºØùêºùêç", url=f"https://t.me/{CHANNEL_USERNAME[1:]}")],
            [InlineKeyboardButton("üì¢ Ôº™ÔºØùêºùêç", url=f"https://t.me/{CHANNEL_USERNAME_2[1:]}")],
            [InlineKeyboardButton("üîê Ôº∂Ôº•ÔºëùêºÔº¶Ôºπ", callback_data="verify")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("‚ö†Ô∏è Y·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥ä·¥è…™…¥ ·¥Ä ü ü ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú± ·¥Ä…¥·¥Ö ·¥†·¥á Ä…™“ì è ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ.", reply_markup=reply_markup)
        return
        
    user_data = users_collection.find_one({"_id": str(user_id)})
    if not user_data:
        user_data = {"credits": 0, "last_update": "N/A", "name": "Unknown"}
    await show_profile(update, context, user_id, user_data)

# ==== ADMIN COMMANDS ====
async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Simple admin check - you might want to implement a more robust system
    if user_id != ADMIN_ID:
        await update.message.reply_text("‚ùå A·¥Ñ·¥Ñ·¥áÍú±Íú± D·¥á…¥…™·¥á·¥Ö.")
        return
        
    users_count = users_collection.count_documents({})
    total_credits = 0
    for user in users_collection.find({}):
        total_credits += user.get("credits", 0)
    
    stats_msg = f"""
‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñ Ôº°Ôº§Ôº≠Ôº©ÔºÆ  ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ

üë• T·¥è·¥õ·¥Ä ü Us·¥á Äs: {users_count}
üíé T·¥è·¥õ·¥Ä ü C Ä·¥á·¥Ö…™·¥õs: {total_credits}
üìä L·¥Äs·¥õ U·¥ò·¥Ö·¥Ä·¥õ·¥á: {datetime.now().strftime('%Y-%m-%d %I:%M:%S %p')}
"""
    await update.message.reply_text(stats_msg)

# ==== MAIN ====
def main():
    app = Application.builder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("credits", credits))
    app.add_handler(CommandHandler("me", me))
    app.add_handler(CommandHandler("buy", buy_command))
    app.add_handler(CommandHandler("adminstats", admin_stats))
    app.add_handler(CommandHandler("addcredits", addcredits_command))
    app.add_handler(CommandHandler("setcredits", setcredits_command))
    app.add_handler(CommandHandler("userinfo", userinfo_command))
    app.add_handler(CommandHandler("broadcast", broadcast_command))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, search))
    app.add_handler(CallbackQueryHandler(verify_callback, pattern="^verify$"))
    app.add_handler(CallbackQueryHandler(button_handler, pattern="^(help|search_prompt|buy|profile)$"))

    print("‚ïè‚ï†‚ïê‚ïê[ùçñùçñùçñÔº∫·¥Ä Ä·¥ã·¥è ìÜó ÔºØÍú±…™…¥·¥õ ùçñùçñùçñ]·öÄ·öÄ·öÄ·öÄ......")
    app.run_polling()

if __name__ == "__main__":
    main()